<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Braunschweiger Squashmeister</title>
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 min-h-screen">
  <div id="app"></div>
  <div id="saveNotification" class="fixed top-4 right-4 bg-green-500 text-white px-6 py-3 rounded-lg shadow-lg transform transition-all duration-300 translate-x-[400px] opacity-0 flex items-center gap-2">
    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
      <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
    </svg>
    <span class="font-semibold">Gespeichert ‚úì</span>
  </div>

  <script>
    const SUPABASE_URL = 'https://bmbwevjncueykikrfdgl.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJtYndldmpuY3VleWtpa3JmZGdsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg4NDQwOTMsImV4cCI6MjA4NDQyMDA5M30.96J60Y7bG8TaZuXGRO5r792PTGSZ7jnfOFzpcz_hT70';
    const urlParams = new URLSearchParams(window.location.search);
    const tournamentIdFromUrl = urlParams.get('tournament');
    const isSpectatorMode = ['spectator', 'tv', '1'].includes(urlParams.get('view'));
    const isFileProtocol = window.location.protocol === 'file:';
    let hasInitializedFromUrl = false;
    let spectatorRefreshIntervalId = null;
    
    // Speicher-Benachrichtigung anzeigen
    function showSaveNotification() {
      const notification = document.getElementById('saveNotification');
      notification.style.transform = 'translateX(0)';
      notification.style.opacity = '1';
      
      setTimeout(() => {
        notification.style.transform = 'translateX(400px)';
        notification.style.opacity = '0';
      }, 2000);
    }

    function buildSpectatorLink() {
      if (!currentTournament?.id) {
        return null;
      }
      const baseUrl = `${window.location.origin}${window.location.pathname}`;
      return `${baseUrl}?tournament=${currentTournament.id}&view=spectator`;
    }

    async function copySpectatorLink() {
      const spectatorLink = buildSpectatorLink();
      if (!spectatorLink) {
        alert('Kein Turnier geladen. Bitte starte zuerst ein Turnier.');
        return;
      }

      try {
        await navigator.clipboard.writeText(spectatorLink);
        alert('Zuschauer-Link kopiert!');
      } catch (error) {
        console.error('Fehler beim Kopieren:', error);
        prompt('Zuschauer-Link kopieren:', spectatorLink);
      }
    }

    async function initializeFromUrl() {
      if (hasInitializedFromUrl || !tournamentIdFromUrl) return;
      hasInitializedFromUrl = true;
      currentStep = 'loading';
      render();
      try {
        await loadTournament(tournamentIdFromUrl);
        if (!currentTournament) {
          currentStep = 'start';
          render();
          stopSpectatorRefresh();
          return;
        }
        startSpectatorRefresh();
      } catch (error) {
        console.error('Fehler beim Laden des Turniers aus URL:', error);
        currentStep = 'start';
        render();
        stopSpectatorRefresh();
      }
    }

    function startSpectatorRefresh() {
      if (!isSpectatorMode || !tournamentIdFromUrl || document.hidden) {
        return;
      }
      stopSpectatorRefresh();
      spectatorRefreshIntervalId = setInterval(async () => {
        try {
          await loadTournament(tournamentIdFromUrl);
        } catch (error) {
          console.error('Fehler beim automatischen Aktualisieren:', error);
        }
      }, 5000);
    }

    function stopSpectatorRefresh() {
      if (spectatorRefreshIntervalId) {
        clearInterval(spectatorRefreshIntervalId);
        spectatorRefreshIntervalId = null;
      }
    }

    // Supabase REST API Hilfsfunktionen
    async function supabaseRequest(endpoint, method = 'GET', body = null) {
      const headers = {
        'apikey': SUPABASE_KEY,
        'Authorization': `Bearer ${SUPABASE_KEY}`,
        'Content-Type': 'application/json',
        'Prefer': 'return=representation'
      };

      const options = {
        method,
        headers,
        cache: 'no-store'
      };

      if (body) {
        options.body = JSON.stringify(body);
      }

      const url = `${SUPABASE_URL}/rest/v1/${endpoint}`;

      try {
        const response = await fetch(url, options);
        
        if (!response.ok) {
          const error = await response.text();
          console.error('Supabase Error Response:', error);
          throw new Error(`HTTP ${response.status}: ${error}`);
        }

        if (response.status === 204) {
          return null;
        }

        const data = await response.json();
        return data;
      } catch (error) {
        console.error('Fetch Error:', error);
        throw error;
      }
    }
    
    let currentStep = 'start';
    let currentTournament = null;
    let tournamentName = '';
    let playerSetup = []; // Array von {type: 'existing'/'new', registeredPlayerId: UUID, name: ''}
    let players = [];
    let matches = [];
    let results = {};
    let allTournaments = [];
    let rounds = [];
    let registeredPlayers = [];
    let selectedPlayerForStats = null;
    let editingPlayerId = null; // NEU: F√ºr das Bearbeiten von Spielernamen
    let playerEloMap = {}; // Elo-Daten: Key = registered_player_id, Value = { elo, elo_games, name, player_index }

    // Hilfsfunktion f√ºr optimierten Spielplan
    function optimizeMatchSchedule(matchList) {
      const scheduled = [];
      const remaining = [...matchList];
      const lastPlayedIndex = {};
      
      while (remaining.length > 0) {
        let bestMatchIndex = -1;
        let bestScore = -1;
        
        for (let i = 0; i < remaining.length; i++) {
          const match = remaining[i];
          const p1LastIndex = lastPlayedIndex[match.player1] ?? -1000;
          const p2LastIndex = lastPlayedIndex[match.player2] ?? -1000;
          const minGap = Math.min(scheduled.length - p1LastIndex, scheduled.length - p2LastIndex);
          
          if (minGap > bestScore) {
            bestScore = minGap;
            bestMatchIndex = i;
          }
        }
        
        const selectedMatch = remaining.splice(bestMatchIndex, 1)[0];
        lastPlayedIndex[selectedMatch.player1] = scheduled.length;
        lastPlayedIndex[selectedMatch.player2] = scheduled.length;
        scheduled.push(selectedMatch);
      }
      
      return scheduled;
    }

    // Alle eindeutigen Runden ermitteln
    function getUniqueRounds() {
      const uniqueRounds = [...new Set(matches.map(m => m.round))];
      return uniqueRounds.sort((a, b) => {
        const numA = parseInt(a.replace('Runde ', ''));
        const numB = parseInt(b.replace('Runde ', ''));
        return numA - numB;
      });
    }

    // Registrierte Spieler laden
    async function loadRegisteredPlayers() {
      try {
        const players = await supabaseRequest('registered_players?select=*&order=name.asc');
        registeredPlayers = players || [];
        return registeredPlayers;
      } catch (error) {
        console.error('Fehler beim Laden der Spieler:', error);
        return [];
      }
    }

    // Elo-Daten f√ºr Turnier laden
    async function loadTournamentElo(tournamentId) {
      try {
        // Tournament_players mit Join auf players_global - WICHTIG: registered_player_id verwenden!
        const endpoint = `tournament_players?select=player_index,registered_player_id,players_global(name,current_elo,elo_games)&tournament_id=eq.${tournamentId}`;
        const data = await supabaseRequest(endpoint);

        if (!data || data.length === 0) {
          console.warn('Keine Elo-Daten gefunden f√ºr Turnier:', tournamentId);
          playerEloMap = {};
          return {};
        }

        // Map erstellen: Key = registered_player_id (wichtig f√ºr korrekten Lookup!)
        const eloMap = {};

        // Pr√ºfen ob Embed funktioniert hat
        const hasEmbeddedData = data.some(entry => entry.players_global !== null);

        if (hasEmbeddedData) {
          // Standard-Weg: Mit Embed
          data.forEach(entry => {
            const regId = entry.registered_player_id;
            const pg = entry.players_global;
            if (regId && pg) {
              eloMap[regId] = {
                elo: pg.current_elo || 1000,
                elo_games: pg.elo_games || 0,
                name: pg.name,
                player_index: entry.player_index
              };
            }
          });
        } else {
          // Fallback: Embed funktioniert nicht, 2-Step-L√∂sung
          console.log('Embed fehlgeschlagen, verwende 2-Step-L√∂sung...');

          // Alle registered_player_ids sammeln
          const registeredPlayerIds = data
            .map(entry => entry.registered_player_id)
            .filter(id => id !== null);

          if (registeredPlayerIds.length > 0) {
            // Players_global in einem zweiten Request laden
            const idsParam = registeredPlayerIds.map(id => `"${id}"`).join(',');
            const playersGlobalEndpoint = `players_global?select=id,name,current_elo,elo_games&id=in.(${idsParam})`;
            const playersGlobalData = await supabaseRequest(playersGlobalEndpoint);

            // Map f√ºr schnellen Zugriff auf players_global Daten
            const playersGlobalMap = {};
            (playersGlobalData || []).forEach(pg => {
              playersGlobalMap[pg.id] = pg;
            });

            // EloMap bef√ºllen
            data.forEach(entry => {
              const regId = entry.registered_player_id;
              if (regId && playersGlobalMap[regId]) {
                const pg = playersGlobalMap[regId];
                eloMap[regId] = {
                  elo: pg.current_elo || 1000,
                  elo_games: pg.elo_games || 0,
                  name: pg.name,
                  player_index: entry.player_index
                };
              }
            });
          }
        }

        playerEloMap = eloMap;
        // Debug: Zeige Keys f√ºr Troubleshooting
        // console.log('EloMap Keys:', Object.keys(playerEloMap));
        return eloMap;
      } catch (error) {
        console.error('Fehler beim Laden der Elo-Daten:', error);
        playerEloMap = {};
        return {};
      }
    }

    // Neuen Spieler registrieren
    async function registerPlayer(name) {
      try {
        const trimmedName = name.trim();
        if (!trimmedName) return null;

        const player = await supabaseRequest('registered_players', 'POST', [{
          name: trimmedName
        }]);
        
        await loadRegisteredPlayers();
        showSaveNotification();
        return player[0];
      } catch (error) {
        console.error('Fehler beim Registrieren:', error);
        alert('Fehler: Spieler existiert bereits oder Name ist ung√ºltig');
        return null;
      }
    }

    // NEU: Spielernamen bearbeiten
    async function updateRegisteredPlayerName(playerId, newName) {
      try {
        const trimmedName = newName.trim();
        if (!trimmedName) {
          alert('Der Name darf nicht leer sein!');
          return false;
        }

        await supabaseRequest(
          `registered_players?id=eq.${playerId}`,
          'PATCH',
          { name: trimmedName }
        );
        
        await loadRegisteredPlayers();
        showSaveNotification();
        editingPlayerId = null;
        render();
        return true;
      } catch (error) {
        console.error('Fehler beim Aktualisieren:', error);
        alert('Fehler beim Speichern des Namens!');
        return false;
      }
    }

    // NEU: Edit-Modus starten
    function startEditingPlayer(playerId) {
      editingPlayerId = playerId;
      render();
      // Focus auf das Input-Feld setzen
      setTimeout(() => {
        const input = document.getElementById('editPlayerInput');
        if (input) {
          input.focus();
          input.select();
        } else {
          console.warn('Edit-Input-Element konnte nicht fokussiert werden');
        }
      }, 50);
    }

    // NEU: Edit-Modus abbrechen
    function cancelEditingPlayer() {
      editingPlayerId = null;
      render();
    }

    // NEU: Namen speichern (wird vom Input aufgerufen)
    async function savePlayerName(playerId) {
      const input = document.getElementById('editPlayerInput');
      if (!input) {
        console.error('Edit-Input-Element nicht gefunden');
        return;
      }
      await updateRegisteredPlayerName(playerId, input.value);
    }

    // Spieler l√∂schen
    async function deleteRegisteredPlayer(playerId) {
      if (!confirm('Diesen Spieler wirklich l√∂schen? Turnierdaten bleiben erhalten.')) {
        return;
      }

      try {
        await supabaseRequest(`registered_players?id=eq.${playerId}`, 'DELETE');
        await loadRegisteredPlayers();
        showSaveNotification();
        render();
      } catch (error) {
        console.error('Fehler beim L√∂schen:', error);
        alert('Fehler beim L√∂schen des Spielers!');
      }
    }

    // Spielerstatistiken laden
    async function loadPlayerStats(playerId) {
      try {
        // Elo-Daten des Spielers laden
        const playerGlobalData = await supabaseRequest(`players_global?id=eq.${playerId}`);
        const playerGlobal = playerGlobalData && playerGlobalData[0] ? playerGlobalData[0] : null;

        // Alle Turniere des Spielers laden
        const playerEntries = await supabaseRequest(`players?registered_player_id=eq.${playerId}&select=tournament_id,name`);

        if (!playerEntries || playerEntries.length === 0) {
          return {
            player: registeredPlayers.find(p => p.id === playerId),
            elo: playerGlobal?.current_elo || 1000,
            eloGames: playerGlobal?.elo_games || 0,
            tournaments: [],
            totalWins: 0,
            totalMatches: 0,
            avgPosition: 0
          };
        }

        const tournamentIds = [...new Set(playerEntries.map(p => p.tournament_id))];
        const stats = {
          player: registeredPlayers.find(p => p.id === playerId),
          elo: playerGlobal?.current_elo || 1000,
          eloGames: playerGlobal?.elo_games || 0,
          tournaments: [],
          totalWins: 0,
          totalMatches: 0,
          positions: []
        };

        // F√ºr jedes Turnier die Statistiken berechnen
        for (const tournamentId of tournamentIds) {
          const tournaments = await supabaseRequest(`tournaments?id=eq.${tournamentId}`);
          const tournament = tournaments[0];
          
          const allPlayers = await supabaseRequest(`players?tournament_id=eq.${tournamentId}&order=player_index.asc`);
          const allMatches = await supabaseRequest(`matches?tournament_id=eq.${tournamentId}`);
          
          // Spieler finden
          const playerInTournament = allPlayers.find(p => p.registered_player_id === playerId);
          if (!playerInTournament) continue;

          // Statistiken berechnen
          let wins = 0;
          let played = 0;
          let pointsFor = 0;
          let pointsAgainst = 0;

          allMatches.forEach(match => {
            if (match.player1_score === null || match.player2_score === null) return;

            const isPlayer1 = match.player1_id === playerInTournament.id;
            const isPlayer2 = match.player2_id === playerInTournament.id;

            if (isPlayer1 || isPlayer2) {
              played++;
              const score1 = match.player1_score;
              const score2 = match.player2_score;

              if (isPlayer1) {
                pointsFor += score1;
                pointsAgainst += score2;
                if (score1 > score2) wins++;
              } else {
                pointsFor += score2;
                pointsAgainst += score1;
                if (score2 > score1) wins++;
              }
            }
          });

          // Platzierung berechnen
          const standings = allPlayers.map(p => {
            const playerStats = { id: p.id, wins: 0, pointDiff: 0 };
            
            allMatches.forEach(m => {
              if (m.player1_score === null || m.player2_score === null) return;
              
              if (m.player1_id === p.id) {
                if (m.player1_score > m.player2_score) playerStats.wins++;
                playerStats.pointDiff += (m.player1_score - m.player2_score);
              } else if (m.player2_id === p.id) {
                if (m.player2_score > m.player1_score) playerStats.wins++;
                playerStats.pointDiff += (m.player2_score - m.player1_score);
              }
            });
            
            return playerStats;
          });

          standings.sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            return b.pointDiff - a.pointDiff;
          });

          const position = standings.findIndex(s => s.id === playerInTournament.id) + 1;

          stats.tournaments.push({
            id: tournament.id,
            name: tournament.name,
            date: new Date(tournament.created_at).toLocaleDateString('de-DE'),
            wins,
            played,
            pointsFor,
            pointsAgainst,
            position
          });

          stats.totalWins += wins;
          stats.totalMatches += played;
          stats.positions.push(position);
        }

        stats.avgPosition = stats.positions.length > 0 
          ? (stats.positions.reduce((a, b) => a + b, 0) / stats.positions.length).toFixed(1)
          : 0;

        return stats;
      } catch (error) {
        console.error('Fehler beim Laden der Statistiken:', error);
        return null;
      }
    }

    // Alle Turniere laden
    async function loadAllTournaments() {
      try {
        const tournaments = await supabaseRequest('tournaments?select=*&order=created_at.desc');
        allTournaments = tournaments || [];
        return allTournaments;
      } catch (error) {
        console.error('Fehler beim Laden der Turniere:', error);
        return [];
      }
    }

    // Turnier laden
    async function loadTournament(tournamentId) {
      try {
        const tournaments = await supabaseRequest(`tournaments?id=eq.${tournamentId}`);
        if (!tournaments || tournaments.length === 0) {
          alert('Turnier nicht gefunden!');
          return;
        }
        const tournament = tournaments[0];
        currentTournament = tournament;
        tournamentName = tournament.name;

        const loadedPlayers = await supabaseRequest(`players?tournament_id=eq.${tournamentId}&order=player_index.asc`);

        // Elo-Daten laden
        await loadTournamentElo(tournamentId);

        players = loadedPlayers.map((p, idx) => {
          // Elo aus playerEloMap holen, Fallback 1000
          let elo = 1000;
          if (p.registered_player_id && playerEloMap[p.registered_player_id]) {
            elo = playerEloMap[p.registered_player_id].elo;
          } else if (!p.registered_player_id) {
            console.warn('Spieler ohne registeredPlayerId beim Laden gefunden:', p.name);
          }

          return {
            id: idx,
            dbId: p.id,
            name: p.name,
            registeredPlayerId: p.registered_player_id,
            elo: elo
          };
        });

        const loadedMatches = await supabaseRequest(`matches?tournament_id=eq.${tournamentId}&order=match_order.asc`);

        matches = loadedMatches.map(m => {
          const player1Index = players.findIndex(p => p.dbId === m.player1_id);
          const player2Index = players.findIndex(p => p.dbId === m.player2_id);

          return {
            id: m.match_id,
            player1: player1Index,
            player2: player2Index,
            round: m.round
          };
        });

        results = {};
        loadedMatches.forEach(m => {
          if (m.player1_score !== null || m.player2_score !== null) {
            results[m.match_id] = {
              player1Score: m.player1_score?.toString() || '',
              player2Score: m.player2_score?.toString() || ''
            };
          }
        });

        rounds = getUniqueRounds();
        currentStep = 'tournament';
        render();
      } catch (error) {
        console.error('Fehler beim Laden des Turniers:', error);
        alert('Fehler beim Laden des Turniers!');
      }
    }

    // Turnier l√∂schen
    async function deleteTournament(tournamentId) {
      if (!confirm('Dieses Turnier wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.')) {
        return;
      }

      try {
        await supabaseRequest(`matches?tournament_id=eq.${tournamentId}`, 'DELETE');
        await supabaseRequest(`players?tournament_id=eq.${tournamentId}`, 'DELETE');
        await supabaseRequest(`tournaments?id=eq.${tournamentId}`, 'DELETE');
        
        await loadAllTournaments();
        render();
        
        showSaveNotification();
      } catch (error) {
        console.error('Fehler beim L√∂schen:', error);
        alert('Fehler beim L√∂schen des Turniers: ' + error.message);
      }
    }

    // Neue Runde hinzuf√ºgen
    async function addNewRound() {
      if (!confirm('Weitere Runde hinzuf√ºgen? Alle Spieler spielen erneut gegeneinander.')) {
        return;
      }

      try {
        const currentRounds = getUniqueRounds();
        const nextRoundNumber = currentRounds.length + 1;
        const roundName = `Runde ${nextRoundNumber}`;

        const newMatches = [];
        for (let i = 0; i < players.length; i++) {
          for (let j = i + 1; j < players.length; j++) {
            newMatches.push({
              id: `${i}-${j}-round${nextRoundNumber}`,
              player1: i,
              player2: j,
              round: roundName
            });
          }
        }

        const optimizedMatches = optimizeMatchSchedule(newMatches);
        const currentMaxOrder = Math.max(...matches.map((_, idx) => idx), -1);

        const matchesData = optimizedMatches.map((match, index) => ({
          tournament_id: currentTournament.id,
          match_id: match.id,
          player1_id: players[match.player1].dbId,
          player2_id: players[match.player2].dbId,
          round: match.round,
          match_order: currentMaxOrder + 1 + index
        }));

        await supabaseRequest('matches', 'POST', matchesData);

        matches = [...matches, ...optimizedMatches];
        rounds = getUniqueRounds();
        
        showSaveNotification();
        render();
      } catch (error) {
        console.error('Fehler beim Hinzuf√ºgen der Runde:', error);
        alert('Fehler beim Hinzuf√ºgen der Runde!');
      }
    }

    // Runde l√∂schen
    async function deleteRound(roundName) {
      if (roundName === 'Runde 1') {
        alert('Die erste Runde kann nicht gel√∂scht werden!');
        return;
      }

      if (!confirm(`${roundName} wirklich l√∂schen? Alle Ergebnisse dieser Runde gehen verloren.`)) {
        return;
      }

      try {
        await supabaseRequest(
          `matches?tournament_id=eq.${currentTournament.id}&round=eq.${roundName}`,
          'DELETE'
        );

        matches = matches.filter(m => m.round !== roundName);
        
        Object.keys(results).forEach(matchId => {
          const match = matches.find(m => m.id === matchId);
          if (!match) {
            delete results[matchId];
          }
        });

        rounds = getUniqueRounds();
        
        showSaveNotification();
        render();
      } catch (error) {
        console.error('Fehler beim L√∂schen der Runde:', error);
        alert('Fehler beim L√∂schen der Runde!');
      }
    }

    // Turnier in Supabase erstellen
    async function createTournamentInDB() {
      try {
        const finalName = tournamentName.trim() || `Turnier ${new Date().toLocaleDateString('de-DE')}`;
        
        const tournament = await supabaseRequest('tournaments', 'POST', [{
          name: finalName,
          with_return_round: false
        }]);

        currentTournament = tournament[0];

        // NEU: F√ºr neue Spieler (ohne registeredPlayerId) erst in registered_players anlegen
        for (let i = 0; i < playerSetup.length; i++) {
          const setup = playerSetup[i];
          if (!setup.registeredPlayerId && setup.name.trim()) {
            // Neuer Spieler - in Datenbank anlegen
            try {
              const newPlayer = await supabaseRequest('registered_players', 'POST', [{
                name: setup.name.trim()
              }]);
              if (newPlayer && newPlayer[0]) {
                playerSetup[i].registeredPlayerId = newPlayer[0].id;
              }
            } catch (error) {
              // Spieler existiert m√∂glicherweise bereits - versuche ihn zu finden
              console.log('Spieler existiert m√∂glicherweise bereits:', setup.name);
              const existingPlayers = await supabaseRequest(`registered_players?name=eq.${encodeURIComponent(setup.name.trim())}`);
              if (existingPlayers && existingPlayers.length > 0) {
                playerSetup[i].registeredPlayerId = existingPlayers[0].id;
              }
            }
          }
        }

        // Spieler erstellen mit registered_player_id
        const playersData = playerSetup.map((setup, index) => ({
          tournament_id: currentTournament.id,
          name: setup.name,
          player_index: index,
          registered_player_id: setup.registeredPlayerId || null
        }));

        const createdPlayers = await supabaseRequest('players', 'POST', playersData);

        players = createdPlayers.map((p, idx) => ({
          id: idx,
          dbId: p.id,
          name: p.name,
          registeredPlayerId: p.registered_player_id
        }));

        const roundMatches = [];
        for (let i = 0; i < players.length; i++) {
          for (let j = i + 1; j < players.length; j++) {
            roundMatches.push({
              id: `${i}-${j}-round1`,
              player1: i,
              player2: j,
              round: 'Runde 1'
            });
          }
        }
        
        const optimizedMatches = optimizeMatchSchedule(roundMatches);

        const matchesData = optimizedMatches.map((match, index) => ({
          tournament_id: currentTournament.id,
          match_id: match.id,
          player1_id: players[match.player1].dbId,
          player2_id: players[match.player2].dbId,
          round: match.round,
          match_order: index
        }));

        await supabaseRequest('matches', 'POST', matchesData);

        // Spielerliste aktualisieren
        await loadRegisteredPlayers();

        matches = optimizedMatches;
        rounds = ['Runde 1'];
        return currentTournament;
      } catch (error) {
        console.error('Fehler beim Erstellen des Turniers:', error);
        alert('Fehler beim Erstellen des Turniers. Bitte √ºberpr√ºfe die Konsole.');
        return null;
      }
    }

    // Spielergebnis aktualisieren
    async function updateMatchResult(matchId, player1Score, player2Score) {
      try {
        const match = matches.find(m => m.id === matchId);
        if (!match) {
          console.error('Match nicht gefunden:', matchId);
          return;
        }

        // Ergebnis in Datenbank speichern
        await supabaseRequest(
          `matches?tournament_id=eq.${currentTournament.id}&match_id=eq.${matchId}`,
          'PATCH',
          {
            player1_score: player1Score || null,
            player2_score: player2Score || null
          }
        );

        // Elo neu berechnen (nur im Nicht-Spectator-Modus)
        if (!isSpectatorMode) {
          try {
            // RPC-Funktion aufrufen, um Elo neu zu berechnen
            await supabaseRequest('rpc/recompute_elo', 'POST', {});

            // Elo-Daten neu laden
            await loadTournamentElo(currentTournament.id);

            // Spieler-Elo in lokaler Liste aktualisieren
            players.forEach(player => {
              if (player.registeredPlayerId && playerEloMap[player.registeredPlayerId]) {
                player.elo = playerEloMap[player.registeredPlayerId].elo;
              } else if (!player.registeredPlayerId) {
                // Warnung f√ºr Spieler ohne registeredPlayerId
                console.warn('Spieler ohne registeredPlayerId gefunden:', player.name);
                player.elo = 1000; // Fallback auf Standardwert
              }
            });
          } catch (eloError) {
            console.error('Fehler beim Neuberechnen der Elo-Werte:', eloError);
            alert('Warnung: Elo-Werte konnten nicht aktualisiert werden. Bitte Seite neu laden.');
          }
        }

        showSaveNotification();
      } catch (error) {
        console.error('Fehler beim Aktualisieren des Spielergebnisses:', error);
        alert('Fehler beim Speichern des Ergebnisses: ' + error.message);
      }
    }

    // Tabelle berechnen
    function calculateStandings() {
      const standings = players.map(player => ({
        ...player,
        played: 0,
        wins: 0,
        pointsFor: 0,
        pointsAgainst: 0,
        pointDiff: 0
        // elo ist bereits in player enthalten
      }));

      matches.forEach(match => {
        const result = results[match.id];
        if (result && result.player1Score !== '' && result.player2Score !== '') {
          const score1 = parseInt(result.player1Score);
          const score2 = parseInt(result.player2Score);

          if (isNaN(score1) || isNaN(score2)) {
            console.warn('Ung√ºltige Punktzahl f√ºr Match:', match.id, score1, score2);
            return;
          }

          standings[match.player1].played++;
          standings[match.player2].played++;
          standings[match.player1].pointsFor += score1;
          standings[match.player1].pointsAgainst += score2;
          standings[match.player2].pointsFor += score2;
          standings[match.player2].pointsAgainst += score1;

          if (score1 > score2) {
            standings[match.player1].wins++;
          } else if (score2 > score1) {
            standings[match.player2].wins++;
          }
        }
      });

      standings.forEach(player => {
        player.pointDiff = player.pointsFor - player.pointsAgainst;
      });

      standings.sort((a, b) => {
        if (b.wins !== a.wins) return b.wins - a.wins;
        return b.pointDiff - a.pointDiff;
      });

      return standings;
    }

    // Render-Funktionen
    function renderFileProtocolWarning() {
      if (!isFileProtocol) return '';

      return `
        <div class="fixed top-0 left-0 right-0 z-50 bg-red-600 text-white px-4 py-3 shadow-lg">
          <div class="max-w-4xl mx-auto flex items-start gap-3">
            <svg class="w-6 h-6 flex-shrink-0 mt-0.5" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clip-rule="evenodd"/>
            </svg>
            <div>
              <p class="font-bold text-lg mb-1">Diese App muss √ºber HTTP(S) laufen!</p>
              <p class="text-sm">Nutze GitHub Pages oder starte lokal z.B. <code class="bg-red-700 px-2 py-0.5 rounded">python3 -m http.server</code> und √∂ffne <code class="bg-red-700 px-2 py-0.5 rounded">http://localhost:8000</code></p>
            </div>
          </div>
        </div>
      `;
    }

    function renderStartScreen() {
      return `
        ${renderFileProtocolWarning()}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 flex items-center justify-center relative overflow-hidden ${isFileProtocol ? 'pt-24' : ''}">
          <div class="absolute inset-0 bg-[radial-gradient(circle_at_50%_50%,rgba(0,61,122,0.4),rgba(255,255,255,0))]"></div>
          <div class="max-w-3xl w-full relative z-10">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-8 md:p-16 text-center border border-white/20">
              <div class="flex items-center justify-center mb-4 md:mb-6">
                <svg class="w-16 h-16 md:w-24 md:h-24 text-yellow-400" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/>
                </svg>
              </div>
              <h1 class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-black text-white mb-4 tracking-tight leading-tight">
                Braunschweiger<br/>
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-yellow-300">Squashmeister</span>
              </h1>
              <p class="text-lg sm:text-xl md:text-2xl text-blue-200 mb-8 md:mb-10 font-light">
                Heute wird rasiert! üî•
              </p>
              <div class="flex flex-col gap-4">
                <button onclick="goToSetup()" class="bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-4 px-12 md:py-5 md:px-16 rounded-full hover:scale-110 active:scale-95 transition-all duration-300 font-bold text-xl md:text-2xl shadow-2xl">
                  Let's Fetz! üöÄ
                </button>
                <button onclick="goToPlayers()" class="bg-white/10 hover:bg-white/20 text-white py-3 px-8 rounded-full transition-all duration-300 font-semibold text-lg border border-white/20">
                  Spieler verwalten üë§
                </button>
                <button onclick="goToArchive()" class="bg-white/10 hover:bg-white/20 text-white py-3 px-8 rounded-full transition-all duration-300 font-semibold text-lg border border-white/20">
                  Vergangene Turniere üìö
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // AKTUALISIERT: renderPlayersScreen mit Edit-Funktion
    function renderPlayersScreen() {
      const fileWarning = renderFileProtocolWarning();
      const playersHTML = registeredPlayers.length === 0 ? `
        <div class="text-center py-12 text-blue-200">
          <p class="text-xl">Noch keine Spieler registriert.</p>
          <p class="text-sm mt-2">F√ºge deinen ersten Spieler hinzu!</p>
        </div>
      ` : registeredPlayers.map(p => {
        // Pr√ºfen ob dieser Spieler gerade bearbeitet wird
        const isEditing = editingPlayerId === p.id;
        
        if (isEditing) {
          return `
            <div class="bg-white/10 rounded-xl p-4 md:p-6 border-2 border-yellow-400">
              <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-3">
                <input
                  type="text"
                  id="editPlayerInput"
                  value="${p.name}"
                  onkeydown="if(event.key === 'Enter') savePlayerName('${p.id}'); if(event.key === 'Escape') cancelEditingPlayer();"
                  class="flex-1 px-4 py-3 bg-white/10 border-2 border-yellow-400 rounded-xl focus:outline-none text-white text-xl font-bold"
                  placeholder="Name eingeben"
                />
                <div class="flex gap-2">
                  <button onclick="savePlayerName('${p.id}')" class="flex-1 sm:flex-none bg-gradient-to-r from-green-500 to-green-400 text-white py-2 px-6 rounded-lg hover:scale-105 active:scale-95 transition-all duration-300 font-bold">
                    ‚úì Speichern
                  </button>
                  <button onclick="cancelEditingPlayer()" class="flex-1 sm:flex-none bg-white/20 hover:bg-white/30 text-white py-2 px-6 rounded-lg transition-all duration-300 font-semibold">
                    ‚úï Abbrechen
                  </button>
                </div>
              </div>
            </div>
          `;
        }
        
        return `
          <div class="bg-white/5 rounded-xl p-4 md:p-6 border border-white/10 hover:bg-white/10 transition-all duration-300">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
              <div class="flex-1">
                <h3 class="text-xl md:text-2xl font-bold text-white">${p.name}</h3>
              </div>
              <div class="flex gap-2 w-full sm:w-auto">
                <button onclick="startEditingPlayer('${p.id}')" class="flex-1 sm:flex-none bg-white/20 hover:bg-white/30 text-white py-2 px-4 rounded-lg transition-all duration-300 font-semibold" title="Namen bearbeiten">
                  ‚úèÔ∏è Bearbeiten
                </button>
                <button onclick="showPlayerStats('${p.id}')" class="flex-1 sm:flex-none bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-2 px-6 rounded-lg hover:scale-105 active:scale-95 transition-all duration-300 font-bold">
                  Statistiken
                </button>
                <button onclick="deleteRegisteredPlayer('${p.id}')" class="flex-1 sm:flex-none bg-red-500/80 hover:bg-red-500 text-white py-2 px-4 rounded-lg transition-all duration-300 font-semibold">
                  üóëÔ∏è
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      return `
        ${fileWarning}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 ${isFileProtocol ? 'pt-24' : ''}">
          <div class="max-w-4xl mx-auto">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-6 md:p-8 border border-white/20">
              <div class="flex items-center justify-between mb-6 md:mb-8">
                <div class="flex items-center">
                  <svg class="w-10 h-10 md:w-12 md:h-12 text-yellow-400 mr-2 md:mr-3" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                  </svg>
                  <h1 class="text-3xl md:text-4xl font-bold text-white">Spielerverwaltung</h1>
                </div>
              </div>

              <div class="mb-6">
                <label class="block text-lg font-semibold text-blue-200 mb-2">Neuen Spieler hinzuf√ºgen</label>
                <div class="flex gap-2">
                  <input
                    type="text"
                    id="newPlayerName"
                    class="flex-1 px-4 py-3 bg-white/10 border-2 border-white/20 rounded-xl focus:border-yellow-400 focus:outline-none text-white placeholder-blue-300 transition-all duration-300"
                    placeholder="Name des Spielers"
                    onkeydown="if(event.key === 'Enter') addNewRegisteredPlayer();"
                  />
                  <button onclick="addNewRegisteredPlayer()" class="bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-3 px-6 rounded-xl hover:scale-105 active:scale-95 transition-all duration-300 font-bold">
                    Hinzuf√ºgen
                  </button>
                </div>
              </div>
              
              <div class="space-y-4 mb-6">
                ${playersHTML}
              </div>

              <button onclick="goToStart()" class="w-full bg-white/10 hover:bg-white/20 text-white py-3 px-6 rounded-xl transition-all duration-300 font-semibold border border-white/20">
                Zur√ºck zur Startseite
              </button>
            </div>
          </div>
        </div>
      `;
    }

    // AKTUALISIERT: renderPlayerStatsScreen mit klickbarer Turnierhistorie
    function renderPlayerStatsScreen(stats) {
      const fileWarning = renderFileProtocolWarning();

      if (!stats || !stats.player) {
        return `${fileWarning}<div class="text-white text-center p-8">Laden...</div>`;
      }

      const tournamentsHTML = stats.tournaments.length === 0 ? `
        <div class="text-center py-8 text-blue-200">
          <p class="text-lg">Noch keine Turniere gespielt.</p>
        </div>
      ` : stats.tournaments.map(t => `
        <div 
          onclick="loadTournament('${t.id}')"
          class="bg-white/5 rounded-xl p-4 border border-white/10 hover:bg-white/15 hover:border-yellow-400/50 transition-all duration-300 cursor-pointer group"
        >
          <div class="flex items-center justify-between mb-2">
            <h4 class="text-lg font-bold text-white group-hover:text-yellow-400 transition-colors duration-300">${t.name}</h4>
            <div class="flex items-center gap-2">
              <span class="text-yellow-400 font-bold">Platz ${t.position}</span>
              <svg class="w-5 h-5 text-white/50 group-hover:text-yellow-400 group-hover:translate-x-1 transition-all duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </div>
          </div>
          <p class="text-blue-200 text-sm mb-2">${t.date}</p>
          <div class="grid grid-cols-3 gap-2 text-sm">
            <div>
              <span class="text-blue-300">Spiele:</span>
              <span class="text-white font-semibold ml-1">${t.played}</span>
            </div>
            <div>
              <span class="text-blue-300">Siege:</span>
              <span class="text-white font-semibold ml-1">${t.wins}</span>
            </div>
            <div>
              <span class="text-blue-300">Punkte:</span>
              <span class="text-white font-semibold ml-1">${t.pointsFor}:${t.pointsAgainst}</span>
            </div>
          </div>
        </div>
      `).join('');

      return `
        ${fileWarning}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 ${isFileProtocol ? 'pt-24' : ''}">
          <div class="max-w-4xl mx-auto">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-6 md:p-8 border border-white/20">
              <div class="mb-6 md:mb-8">
                <h1 class="text-3xl md:text-4xl font-bold text-white mb-4">${stats.player.name}</h1>

                <div class="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                  <div class="bg-white/5 rounded-xl p-4 border border-white/10 text-center">
                    <p class="text-blue-200 text-sm mb-1">Aktueller Elo</p>
                    <p class="text-3xl font-bold text-yellow-300">${stats.elo}</p>
                    <p class="text-xs text-blue-300 mt-1">${stats.eloGames} Spiele</p>
                  </div>
                  <div class="bg-white/5 rounded-xl p-4 border border-white/10 text-center">
                    <p class="text-blue-200 text-sm mb-1">Turniere</p>
                    <p class="text-3xl font-bold text-white">${stats.tournaments.length}</p>
                  </div>
                  <div class="bg-white/5 rounded-xl p-4 border border-white/10 text-center">
                    <p class="text-blue-200 text-sm mb-1">Siege gesamt</p>
                    <p class="text-3xl font-bold text-green-400">${stats.totalWins}</p>
                  </div>
                  <div class="bg-white/5 rounded-xl p-4 border border-white/10 text-center">
                    <p class="text-blue-200 text-sm mb-1">‚åÄ Platzierung</p>
                    <p class="text-3xl font-bold text-yellow-400">${stats.avgPosition}</p>
                  </div>
                </div>

                <h2 class="text-xl font-bold text-white mb-4">Turnierhistorie</h2>
                <p class="text-sm text-blue-300 mb-3">Klicke auf ein Turnier, um es anzuzeigen</p>
                <div class="space-y-3">
                  ${tournamentsHTML}
                </div>
              </div>

              <button onclick="goToPlayers()" class="w-full bg-white/10 hover:bg-white/20 text-white py-3 px-6 rounded-xl transition-all duration-300 font-semibold border border-white/20">
                Zur√ºck zur Spielerverwaltung
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderArchiveScreen() {
      const fileWarning = renderFileProtocolWarning();
      const tournamentsHTML = allTournaments.length === 0 ? `
        <div class="text-center py-12 text-blue-200">
          <p class="text-xl">Noch keine Turniere vorhanden.</p>
          <p class="text-sm mt-2">Erstelle dein erstes Turnier!</p>
        </div>
      ` : allTournaments.map(t => {
        const date = new Date(t.created_at).toLocaleDateString('de-DE', {
          day: '2-digit',
          month: '2-digit',
          year: 'numeric',
          hour: '2-digit',
          minute: '2-digit'
        });
        
        return `
          <div class="bg-white/5 rounded-xl p-4 md:p-6 border border-white/10 hover:bg-white/10 transition-all duration-300">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4">
              <div class="flex-1">
                <h3 class="text-xl md:text-2xl font-bold text-white mb-1">${t.name}</h3>
                <p class="text-blue-200 text-sm">${date}</p>
              </div>
              <div class="flex gap-2 w-full sm:w-auto">
                <button onclick="loadTournament('${t.id}')" class="flex-1 sm:flex-none bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-2 px-6 rounded-lg hover:scale-105 active:scale-95 transition-all duration-300 font-bold">
                  √ñffnen
                </button>
                <button onclick="deleteTournament('${t.id}')" class="flex-1 sm:flex-none bg-red-500/80 hover:bg-red-500 text-white py-2 px-6 rounded-lg transition-all duration-300 font-semibold">
                  L√∂schen
                </button>
              </div>
            </div>
          </div>
        `;
      }).join('');

      return `
        ${fileWarning}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 ${isFileProtocol ? 'pt-24' : ''}">
          <div class="max-w-4xl mx-auto">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-6 md:p-8 border border-white/20">
              <div class="flex items-center justify-between mb-6 md:mb-8">
                <div class="flex items-center">
                  <svg class="w-10 h-10 md:w-12 md:h-12 text-yellow-400 mr-2 md:mr-3" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"/>
                  </svg>
                  <h1 class="text-3xl md:text-4xl font-bold text-white">Vergangene Turniere</h1>
                </div>
              </div>
              
              <div class="space-y-4 mb-6">
                ${tournamentsHTML}
              </div>

              <button onclick="goToStart()" class="w-full bg-white/10 hover:bg-white/20 text-white py-3 px-6 rounded-xl transition-all duration-300 font-semibold border border-white/20">
                Zur√ºck zur Startseite
              </button>
            </div>
          </div>
        </div>
      `;
    }

    function renderSetupScreen() {
      const fileWarning = renderFileProtocolWarning();
      const playerInputsHTML = playerSetup.map((setup, index) => {
        const selectHTML = `
          <select
            onchange="updatePlayerSetup(${index}, this.value)"
            class="flex-1 px-4 py-3 bg-white/10 border-2 border-white/20 rounded-xl focus:border-yellow-400 focus:outline-none text-white transition-all duration-300"
          >
            <option value="">-- Neuer Spieler --</option>
            ${registeredPlayers.map(p => `
              <option value="${p.id}" ${setup.registeredPlayerId === p.id ? 'selected' : ''}>${p.name}</option>
            `).join('')}
          </select>
        `;

        const nameInput = setup.registeredPlayerId ? '' : `
          <input
            type="text"
            value="${setup.name}"
            onchange="updatePlayerName(${index}, this.value)"
            class="flex-1 px-4 py-3 bg-white/10 border-2 border-white/20 rounded-xl focus:border-yellow-400 focus:outline-none text-white placeholder-blue-300 transition-all duration-300"
            placeholder="Name eingeben"
          />
        `;

        return `
          <div class="space-y-2">
            <label class="block text-sm font-semibold text-blue-200">Spieler ${index + 1}</label>
            <div class="flex gap-2">
              ${selectHTML}
              ${nameInput}
              ${playerSetup.length > 2 ? `
                <button
                  onclick="removePlayerFromSetup(${index})"
                  class="px-3 py-2 md:px-4 md:py-2 bg-red-500/80 hover:bg-red-500 text-white rounded-xl transition-all duration-300 font-semibold hover:scale-110 active:scale-95 text-lg md:text-xl"
                >
                  ‚àí
                </button>
              ` : ''}
            </div>
            ${!setup.registeredPlayerId && setup.name ? `
              <p class="text-xs text-yellow-400/80 ml-1">‚ö° Wird automatisch als neuer Spieler gespeichert</p>
            ` : ''}
          </div>
        `;
      }).join('');

      return `
        ${fileWarning}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 ${isFileProtocol ? 'pt-24' : ''}">
          <div class="max-w-2xl mx-auto">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-6 md:p-8 border border-white/20">
              <div class="flex items-center justify-center mb-6 md:mb-8">
                <svg class="w-10 h-10 md:w-12 md:h-12 text-yellow-400 mr-2 md:mr-3" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/>
                </svg>
                <h1 class="text-3xl md:text-4xl font-bold text-white">Neues Turnier</h1>
              </div>
              
              <div class="mb-6">
                <label class="block text-lg font-semibold text-blue-200 mb-2">Turniername</label>
                <input
                  type="text"
                  id="tournamentNameInput"
                  value="${tournamentName}"
                  onchange="updateTournamentName(this.value)"
                  class="w-full px-4 py-3 bg-white/10 border-2 border-white/20 rounded-xl focus:border-yellow-400 focus:outline-none text-white placeholder-blue-300 transition-all duration-300 text-base"
                  placeholder="z.B. Winterturnier 2025"
                />
              </div>

              <div class="mb-4">
                <label class="block text-lg font-semibold text-blue-200 mb-2">Teilnehmer</label>
              </div>
              
              <div id="playerInputs" class="space-y-4 mb-6">
                ${playerInputsHTML}
              </div>

              <button onclick="addPlayerToSetup()" class="w-full mb-6 bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-3 px-6 rounded-xl hover:scale-105 active:scale-95 transition-all duration-300 font-bold text-base md:text-lg flex items-center justify-center gap-2 shadow-lg">
                <span class="text-2xl">+</span>
                Noch einer!
              </button>
              
              <div class="flex gap-3 md:gap-4">
                <button onclick="goToStart()" class="flex-1 bg-white/10 hover:bg-white/20 text-white py-3 px-4 md:px-6 rounded-xl transition-all duration-300 font-semibold border border-white/20 hover:scale-105 text-base">
                  Zur√ºck
                </button>
                <button onclick="startTournament()" class="flex-1 bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-3 px-4 md:px-6 rounded-xl hover:scale-105 active:scale-95 transition-all duration-300 font-bold shadow-lg text-base">
                  Los geht's!
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderTournamentScreen() {
      const fileWarning = renderFileProtocolWarning();
      const standings = calculateStandings();
      const currentRounds = getUniqueRounds();
      
      let standingsHTML = standings.map((player, index) => `
        <tr class="${index % 2 === 0 ? 'bg-white/5' : 'bg-white/10'} hover:bg-white/20 transition-all duration-300">
          <td class="py-2 md:py-3 px-2 md:px-4 font-semibold text-yellow-400 text-base md:text-lg">
            ${index === 0 ? 'üëë ' : ''}${index + 1}
          </td>
          <td class="py-2 md:py-3 px-2 md:px-4 font-semibold text-white text-sm md:text-base">
            ${player.name} <span class="text-yellow-300 font-normal">(${player.elo || 1000})</span>
          </td>
          <td class="py-2 md:py-3 px-2 md:px-4 text-center text-blue-200 text-sm md:text-base">${player.played}</td>
          <td class="py-2 md:py-3 px-2 md:px-4 text-center font-semibold text-white text-sm md:text-base">${player.wins}</td>
          <td class="py-2 md:py-3 px-2 md:px-4 text-center text-sm md:text-base">
            <span class="${player.pointDiff > 0 ? 'text-green-400' : player.pointDiff < 0 ? 'text-red-400' : 'text-blue-200'} font-semibold">
              ${player.pointDiff > 0 ? '+' : ''}${player.pointDiff}
            </span>
          </td>
        </tr>
      `).join('');

      let matchesHTML = '';
      currentRounds.forEach(round => {
        const roundMatches = matches.filter(m => m.round === round);
        if (roundMatches.length === 0) return;
        
        matchesHTML += `
          <div>
            <div class="flex items-center justify-between mb-2 md:mb-3">
              <h3 class="text-lg md:text-xl font-bold text-yellow-400">${round}</h3>
              ${!isSpectatorMode && round !== 'Runde 1' ? `
                <button onclick="deleteRound('${round}')" class="bg-red-500/80 hover:bg-red-500 text-white py-1 px-3 rounded-lg text-sm transition-all duration-300 font-semibold">
                  Runde l√∂schen
                </button>
              ` : ''}
            </div>
            <div class="space-y-2 md:space-y-3">
              ${roundMatches.map(match => `
                <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 sm:gap-4 p-3 md:p-4 bg-white/5 rounded-xl border border-white/10 hover:bg-white/10 transition-all duration-300">
                  <div class="flex-1 text-center sm:text-right font-semibold text-white text-sm md:text-base">
                    ${players[match.player1].name}
                  </div>
                  <div class="flex items-center justify-center gap-2 sm:gap-4">
                    <input 
                      type="number" 
                      min="0" 
                      value="${results[match.id]?.player1Score || ''}"
                      ${isSpectatorMode ? 'disabled' : `onchange="updateResult('${match.id}', 'player1Score', this.value)"`}
                      class="w-16 md:w-20 px-2 md:px-3 py-2 bg-white/10 border-2 border-white/20 rounded-lg text-center font-bold text-base md:text-lg text-white focus:border-yellow-400 focus:outline-none ${isSpectatorMode ? 'opacity-70 cursor-not-allowed' : ''}"
                      placeholder="0"
                    />
                    <span class="text-xl md:text-2xl font-bold text-yellow-400">:</span>
                    <input 
                      type="number" 
                      min="0" 
                      value="${results[match.id]?.player2Score || ''}"
                      ${isSpectatorMode ? 'disabled' : `onchange="updateResult('${match.id}', 'player2Score', this.value)"`}
                      class="w-16 md:w-20 px-2 md:px-3 py-2 bg-white/10 border-2 border-white/20 rounded-lg text-center font-bold text-base md:text-lg text-white focus:border-yellow-400 focus:outline-none ${isSpectatorMode ? 'opacity-70 cursor-not-allowed' : ''}"
                      placeholder="0"
                    />
                  </div>
                  <div class="flex-1 text-center sm:text-left font-semibold text-white text-sm md:text-base">
                    ${players[match.player2].name}
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      });

      return `
        ${fileWarning}
        <div class="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-slate-900 p-4 md:p-8 ${isFileProtocol ? 'pt-24' : ''}">
          <div class="max-w-6xl mx-auto">
            <div class="bg-gradient-to-br from-white/10 to-white/5 backdrop-blur-xl rounded-3xl shadow-2xl p-4 md:p-8 mb-8 border border-white/20">
              <div class="flex flex-col sm:flex-row items-center justify-between mb-6 md:mb-8 gap-4">
                <div class="flex items-center">
                  <svg class="w-10 h-10 md:w-12 md:h-12 text-yellow-400 mr-2 md:mr-3" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z"/>
                  </svg>
                  <div>
                    <h1 class="text-2xl md:text-3xl lg:text-4xl font-bold text-white">${currentTournament?.name || 'Turnier'}</h1>
                  </div>
                </div>
                <div class="flex flex-col sm:flex-row gap-2 sm:gap-3">
                  ${!isSpectatorMode ? `
                    <button onclick="copySpectatorLink()" class="bg-white/10 hover:bg-white/20 text-white py-2 px-4 md:px-6 rounded-xl transition-all duration-300 font-semibold border border-white/20 hover:scale-105 text-sm md:text-base">
                      Link teilen üîó
                    </button>
                    <button onclick="resetTournament()" class="bg-red-500/80 hover:bg-red-500 text-white py-2 px-4 md:px-6 rounded-xl transition-all duration-300 font-semibold hover:scale-110 active:scale-95 text-sm md:text-base">
                      Startseite
                    </button>
                  ` : ''}
                </div>
              </div>
              ${isSpectatorMode ? `
                <div class="mb-6 rounded-xl border border-yellow-400/40 bg-yellow-400/10 px-4 py-3 text-yellow-200 text-sm md:text-base">
                  Zuschaueransicht aktiv: Ergebnisse sind schreibgesch√ºtzt.
                </div>
              ` : ''}

              <div class="mb-6 md:mb-8">
                <div class="flex items-center mb-3 md:mb-4">
                  <svg class="w-6 h-6 md:w-8 md:h-8 text-yellow-400 mr-2" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/>
                  </svg>
                  <h2 class="text-xl md:text-2xl font-bold text-white">Live Tabelle</h2>
                </div>
                <div class="overflow-x-auto -mx-4 md:mx-0 px-4 md:px-0">
                  <table class="w-full min-w-[500px]">
                    <thead>
                      <tr class="bg-gradient-to-r from-blue-600 to-blue-700">
                        <th class="py-2 md:py-3 px-2 md:px-4 text-left font-semibold text-yellow-300 text-sm md:text-base">Platz</th>
                        <th class="py-2 md:py-3 px-2 md:px-4 text-left font-semibold text-yellow-300 text-sm md:text-base">Name (Elo)</th>
                        <th class="py-2 md:py-3 px-2 md:px-4 text-center font-semibold text-yellow-300 text-sm md:text-base">Spiele</th>
                        <th class="py-2 md:py-3 px-2 md:px-4 text-center font-semibold text-yellow-300 text-sm md:text-base">Siege</th>
                        <th class="py-2 md:py-3 px-2 md:px-4 text-center font-semibold text-yellow-300 text-sm md:text-base">Diff.</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${standingsHTML}
                    </tbody>
                  </table>
                </div>
              </div>

              <div>
                <div class="flex items-center justify-between mb-3 md:mb-4">
                  <h2 class="text-xl md:text-2xl font-bold text-white">Spielplan & Ergebnisse</h2>
                  ${!isSpectatorMode ? `
                    <button onclick="addNewRound()" class="bg-gradient-to-r from-yellow-400 to-yellow-300 text-blue-900 py-2 px-4 md:px-6 rounded-xl hover:scale-105 active:scale-95 transition-all duration-300 font-bold text-sm md:text-base">
                      + Weitere Runde
                    </button>
                  ` : ''}
                </div>
                <div class="space-y-4 md:space-y-6">
                  ${matchesHTML}
                </div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    // Event-Handler
    function goToStart() {
      currentStep = 'start';
      editingPlayerId = null;
      render();
    }

    async function goToPlayers() {
      await loadRegisteredPlayers();
      editingPlayerId = null;
      currentStep = 'players';
      render();
    }

    async function goToSetup() {
      await loadRegisteredPlayers();
      tournamentName = '';
      playerSetup = [
        { registeredPlayerId: null, name: '' },
        { registeredPlayerId: null, name: '' }
      ];
      currentStep = 'setup';
      render();
    }

    async function goToArchive() {
      currentStep = 'archive';
      await loadAllTournaments();
      render();
    }

    async function showPlayerStats(playerId) {
      selectedPlayerForStats = playerId;
      currentStep = 'stats-loading';
      render();
      
      const stats = await loadPlayerStats(playerId);
      currentStep = 'stats';
      render();
      
      // Re-render with stats
      const app = document.getElementById('app');
      app.innerHTML = renderPlayerStatsScreen(stats);
    }

    async function addNewRegisteredPlayer() {
      const input = document.getElementById('newPlayerName');
      if (!input) {
        console.error('Input-Element "newPlayerName" nicht gefunden');
        return;
      }

      const name = input.value.trim();

      if (!name) {
        alert('Bitte einen Namen eingeben!');
        return;
      }

      const player = await registerPlayer(name);
      if (player) {
        input.value = '';
        render();
      }
    }

    function addPlayerToSetup() {
      playerSetup.push({ registeredPlayerId: null, name: '' });
      render();
    }

    function removePlayerFromSetup(index) {
      if (playerSetup.length > 2) {
        playerSetup.splice(index, 1);
        render();
      }
    }

    function updatePlayerSetup(index, registeredPlayerId) {
      if (registeredPlayerId) {
        const player = registeredPlayers.find(p => p.id === registeredPlayerId);
        if (!player) {
          console.error('Spieler nicht gefunden:', registeredPlayerId);
          alert('Fehler: Spieler nicht gefunden!');
          return;
        }
        playerSetup[index] = {
          registeredPlayerId: registeredPlayerId,
          name: player.name
        };
      } else {
        playerSetup[index] = {
          registeredPlayerId: null,
          name: ''
        };
      }
      render();
    }

    function updatePlayerName(index, name) {
      playerSetup[index].name = name;
    }

    function updateTournamentName(value) {
      tournamentName = value;
    }

    async function startTournament() {
      // Validierung
      const hasEmptyNames = playerSetup.some(p => !p.name && !p.registeredPlayerId);
      if (hasEmptyNames) {
        alert('Bitte alle Spielernamen ausf√ºllen!');
        return;
      }

      const tournament = await createTournamentInDB();
      if (tournament) {
        currentStep = 'tournament';
        render();
      }
    }

    async function updateResult(matchId, field, value) {
      if (isSpectatorMode) {
        return;
      }
      if (!results[matchId]) {
        results[matchId] = { player1Score: '', player2Score: '' };
      }
      results[matchId][field] = value;
      
      await updateMatchResult(
        matchId, 
        results[matchId].player1Score, 
        results[matchId].player2Score
      );
      
      render();
    }

    function resetTournament() {
      if (confirm('Zur Startseite zur√ºck?')) {
        currentTournament = null;
        tournamentName = '';
        playerSetup = [];
        players = [];
        matches = [];
        results = {};
        rounds = [];
        currentStep = 'start';
        render();
      }
    }

    function render() {
      const app = document.getElementById('app');
      if (!app) {
        console.error('App-Element nicht gefunden');
        return;
      }

      if (currentStep === 'start') {
        app.innerHTML = renderStartScreen();
      } else if (currentStep === 'players') {
        app.innerHTML = renderPlayersScreen();
      } else if (currentStep === 'stats-loading') {
        app.innerHTML = '<div class="min-h-screen flex items-center justify-center text-white text-xl">Lade Statistiken...</div>';
      } else if (currentStep === 'loading') {
        app.innerHTML = '<div class="min-h-screen flex items-center justify-center text-white text-xl">Lade Turnier...</div>';
      } else if (currentStep === 'archive') {
        app.innerHTML = renderArchiveScreen();
      } else if (currentStep === 'setup') {
        app.innerHTML = renderSetupScreen();
        const tournamentInput = document.getElementById('tournamentNameInput');
        if (tournamentInput) {
          tournamentInput.value = tournamentName;
        }
      } else if (currentStep === 'tournament') {
        app.innerHTML = renderTournamentScreen();
      }
    }

    // Initial render
    if (tournamentIdFromUrl) {
      currentStep = 'loading';
    }
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        stopSpectatorRefresh();
      } else {
        startSpectatorRefresh();
      }
    });
    render();
    initializeFromUrl();
  </script>
</body>
</html>
